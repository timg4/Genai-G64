<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wind Turbine Inspection Assistant</title>
  <link rel="icon" type="image/png" sizes="32x32" href="/static/logo_tab_2.png" id="appFavicon" />
  <style>
    :root {
      --bg: #0c131c;
      --panel: #0f1a26;
      --panel-2: #122031;
      --text: #e7eef6;
      --muted: #9fb0c3;
      --border: #233a4f;
      --accent: #22c55e;
      --accent-2: #38bdf8;
      --danger: #ef4444;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: "Trebuchet MS", "Segoe UI", sans-serif;
      --display: "Trebuchet MS", "Segoe UI", sans-serif;
      --panel-body-vh: 70vh;
      --panel-offset: 260px;
      --panel-height: auto;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
    }
    a { color: inherit; }

    .app {
      max-width: 100%;
      margin: 0 auto;
      padding: 16px 16px 16px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
    }
    .title {
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .logo-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .logo-wrap.logo-right {
      margin-left: auto;
      justify-content: flex-end;
      max-width: clamp(300px, 45vw, 760px);
    }
    .logo {
      width: 141px;
      height: 141px;
      object-fit: contain;
      border-radius: 11px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.04);
      padding: 1px;
    }
    .logo.logo-plain {
      border: 0;
      background: transparent;
      padding: 0;
      border-radius: 0;
      width: 100%;
      max-width: clamp(300px, 45vw, 760px);
      height: auto;
      max-height: 170px;
      object-position: right center;
    }
    .logo.is-spinning {
      animation: logo-spin 1.2s ease-in-out;
    }
    .title h1 {
      margin: 0;
      font-size: 40px;
      letter-spacing: .2px;
      font-family: var(--display);
      white-space: nowrap;
    }
    .subtitle {
      font-size: 21px;
      color: var(--muted);
      margin-top: 2px;
      text-indent: 20px;
    }
    .pill {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,.03);
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(280px, 1fr) minmax(360px, 2.2fr) minmax(340px, 1.5fr);
      gap: 16px;
      align-items: stretch;
      transition: grid-template-columns .35s ease;
    }
    @media (max-width: 1200px) {
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.04) 0%, rgba(255,255,255,.02) 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: var(--panel-height);
      min-height: 0;
      transition: transform .35s ease, width .35s ease, box-shadow .35s ease;
    }
    .inputs-card { grid-column: 1; z-index: 2; position: relative; overflow: visible; }
    .conversation-card { grid-column: 2; z-index: 1; }
    .manuals-card { grid-column: 3; z-index: 1; }
    .scada-overlay.card,
    .image-overlay.card {
      position: absolute;
      top: 0;
      left: 100%;
      margin-left: 10px;
      width: clamp(340px, 34vw, 460px);
      height: calc(100% + 4px);
      background: var(--panel);
      background-image: none;
      opacity: 0;
      pointer-events: none;
      transform: translate(12px, -4px);
      transition: opacity .25s ease, transform .25s ease;
      z-index: 4;
    }
    .scada-overlay.card.is-open,
    .image-overlay.card.is-open {
      opacity: 1;
      pointer-events: auto;
      transform: translate(0, -4px);
    }
    @media (max-width: 1200px) {
      .scada-overlay.card,
      .image-overlay.card {
        position: static;
        width: auto;
        height: auto;
        margin-left: 0;
        opacity: 1;
        pointer-events: auto;
        transform: none;
      }
      .scada-overlay.card:not(.is-open),
      .image-overlay.card:not(.is-open) {
        display: none;
      }
    }
    .card .card-h {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(0,0,0,.12);
      min-height: var(--card-h-height, 0px);
    }
    .card .card-h h2 {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .3px;
      text-transform: uppercase;
    }
    .card .card-b {
      padding: 16px;
      flex: 1;
      min-height: 0;
      overflow-y: auto;
    }
    .input-section {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(0,0,0,.14);
      margin-bottom: 12px;
    }
    .input-section:last-child {
      margin-bottom: 0;
    }
    .input-section-h {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      margin-bottom: 6px;
    }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 12px 0 6px;
    }
    textarea, select, input[type="text"], input[type="number"], input[type="datetime-local"] {
      width: 100%;
      color: var(--text);
      background: rgba(0,0,0,.20);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
    }
    textarea { min-height: 86px; resize: vertical; }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .small {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .disclaimer {
      margin-bottom: 10px;
    }

    .drop {
      border: 1px dashed rgba(255,255,255,.22);
      background: rgba(0,0,0,.14);
      border-radius: 12px;
      padding: 14px;
      text-align: center;
      cursor: pointer;
      transition: .15s ease;
      user-select: none;
    }
    .drop.drag {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(34,197,94,.18);
    }
    .drop b { color: var(--text); }

    .chips { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .chip {
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      cursor: pointer;
    }
    .chip:hover { border-color: rgba(255,255,255,.35); }

    .file-list { margin-top: 10px; display: grid; gap: 10px; }
    .file-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0,0,0,.18);
    }
    .file-item.is-ignored {
      opacity: .5;
    }
    .file-head { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .file-name { font-family: var(--mono); font-size: 12px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .btn-mini {
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 10px;
      padding: 6px 10px;
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
    }
    .btn-mini.is-loading {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .btn-mini:hover { border-color: rgba(255,255,255,.35); }

    .actions {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-top: 16px;
    }
    .btn {
      background: var(--accent);
      border: 0;
      color: #062015;
      font-weight: 700;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      width: 100%;
    }
    .btn.is-muted {
      background: rgba(34,197,94,.45);
      color: #0b2d1e;
    }
    .btn.is-muted:disabled {
      opacity: .85;
    }
    .btn-inline {
      width: auto;
      padding: 8px 14px;
    }
    .btn:disabled {
      opacity: .55;
      cursor: not-allowed;
    }
    .btn-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .btn-row .btn {
      width: auto;
    }

    /* Chat area */
    .chat-wrap {
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1;
      min-height: 0;
      height: auto;
      max-height: none;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .chat-wrap > * {
      flex-shrink: 0;
    }
    .retrieval-wrap {
      flex: 1;
      min-height: 0;
      height: auto;
      max-height: none;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .current-input {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(0,0,0,.18);
      color: var(--text);
      font-size: 13px;
      line-height: 1.5;
    }
    .current-input .label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      margin-bottom: 6px;
    }
    .panel-h {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .panel-h .label {
      margin: 0;
    }
    .panel-body.collapsed {
      display: none;
    }
    .current-reco {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(0,0,0,.22);
      color: var(--text);
      font-size: 16px;
      line-height: 1.5;
      max-height: none;
      overflow: visible;
    }
    .current-reco .label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      margin-bottom: 6px;
    }
    .current-reco .panel-body {
      max-height: none;
      overflow: visible;
      padding-right: 0;
    }
    .processing-hint {
      display: none !important;
    }
    .chat {
      --chat-body-height: 520px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: none;
      overflow: visible;
      padding-right: 0;
      flex: 1 0 auto;
    }
    .msg .m-b {
      max-height: none;
      overflow: visible;
      padding-right: 6px;
    }
    .msg {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: visible;
      background: rgba(0,0,0,.16);
    }
    .msg .m-h {
      padding: 10px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(0,0,0,.10);
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
    }
    .msg .m-h .left {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .msg .m-h .right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .msg.diagnosis-card .m-h .right .pill {
      display: none;
    }
    .collapse-btn {
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 999px;
      width: 24px;
      height: 24px;
      padding: 0;
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      text-transform: none;
      letter-spacing: normal;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .collapse-btn::before {
      content: "▾";
      line-height: 1;
    }
    .collapse-btn.is-collapsed::before {
      content: "▸";
    }
    .msg.collapsed .m-b {
      display: none;
    }
    .msg .m-b {
      padding: 14px;
      white-space: pre-wrap;
      line-height: 1.5;
    }
    .mono { font-family: var(--mono); }
    .chat-image {
      display: flex;
      gap: 12px;
      max-width: 100%;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .chat-image img {
      width: 100%;
      max-width: clamp(180px, 32vw, 320px);
      max-height: clamp(160px, calc(var(--chat-body-height) - 260px), 320px);
      object-fit: contain;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0b1118;
      flex: 0 0 auto;
    }
    .chat-image .caption {
      font-size: 12px;
      color: var(--muted);
      word-break: break-all;
    }
    .chat-details {
      display: grid;
      gap: 6px;
      min-width: 200px;
      flex: 1;
    }
    .chat-details .label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
    }

    .spinner {
      display: inline-block;
      width: 14px; height: 14px;
      border: 2px solid rgba(255,255,255,.25);
      border-top-color: var(--accent);
      border-radius: 999px;
      animation: spin 1s linear infinite;
      vertical-align: -2px;
    }
    .inspect-inline {
      margin-top: 10px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .inspect-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--accent);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(34,197,94,.35);
      background: rgba(34,197,94,.12);
    }
    .inspect-status {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      display: inline-flex;
      border: 1px solid transparent;
      background: rgba(0,0,0,.15);
    }
    .inspect-status.pending {
      color: #f59e0b;
      border-color: rgba(245,158,11,.45);
      background: rgba(245,158,11,.12);
    }
    .inspect-status.accepted {
      color: var(--accent);
      border-color: rgba(34,197,94,.35);
      background: rgba(34,197,94,.12);
    }
    .inspect-status.rejected {
      color: var(--danger);
      border-color: rgba(239,68,68,.4);
      background: rgba(239,68,68,.12);
    }

    .risk-pill {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      display: inline-flex;
      border: 1px solid transparent;
      background: rgba(0,0,0,.15);
      text-transform: none;
      letter-spacing: normal;
      white-space: nowrap;
    }
    .risk-pill.high_risk {
      color: var(--danger);
      border-color: rgba(239,68,68,.4);
      background: rgba(239,68,68,.12);
    }
    .risk-pill.medium_risk {
      color: #f59e0b;
      border-color: rgba(245,158,11,.45);
      background: rgba(245,158,11,.12);
    }
    .risk-pill.low_risk {
      color: var(--accent-2);
      border-color: rgba(56,189,248,.35);
      background: rgba(56,189,248,.12);
    }
    .risk-pill.no_risk {
      color: var(--accent);
      border-color: rgba(34,197,94,.35);
      background: rgba(34,197,94,.12);
    }
    .risk-pill.not_classified {
      color: var(--muted);
      border-color: rgba(159,176,195,.35);
      background: rgba(159,176,195,.12);
    }
    .image-review {
      display: grid;
      gap: 12px;
    }
    .archive-image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }
    .archive-image {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      overflow: hidden;
    }
    .archive-image img {
      width: 100%;
      height: 140px;
      object-fit: contain;
      display: block;
      background: #0b1118;
    }
    .archive-image-name {
      padding: 8px 10px;
      font-size: 11px;
      color: var(--muted);
      word-break: break-all;
    }
    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .image-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      overflow: hidden;
    }
    .image-card.is-ignored {
      opacity: .5;
    }
    .image-preview {
      width: 100%;
      height: 160px;
      object-fit: cover;
      display: block;
      background: #0b1118;
    }
    .image-meta {
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .image-name {
      font-size: 12px;
      color: var(--muted);
      word-break: break-all;
    }
    .image-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    @keyframes logo-spin { to { transform: rotate(360deg); } }

    /* Table */
    table { width: 100%; border-collapse: collapse; }
    th, td {
      text-align: left;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
    }
    th { font-size: 12px; color: var(--muted); font-weight: 600; background: rgba(0,0,0,.10); }
    td { font-size: 13px; }
    .snippet { color: var(--muted); font-size: 12px; }
    .snippet-row { display: flex; gap: 10px; align-items: flex-start; justify-content: space-between; }
    .chunk-toggle { white-space: nowrap; }
    .chunk-detail td { padding-top: 0; }
    .chunk-detail-inner {
      margin: 8px 0 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,.16);
    }
    .chunk-detail-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chunk-meta { font-size: 11px; color: var(--muted); }
    .chunk-text {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }
    .retrieval-list-header {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 92px;
      gap: 10px;
      align-items: center;
      padding: 9px 20px;
      font-size: 9px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      box-shadow: 0 8px 20px rgba(0,0,0,.22);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .retrieval-actions-label {
      text-align: right;
    }
    .retrieval-list {
      display: grid;
      gap: 8px;
      padding: 10px;
    }
    .retrieval-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,.14);
      padding: 8px 10px;
      font-size: 12px;
    }
    .retrieval-head {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 92px;
      gap: 12px;
      align-items: start;
    }
    .retrieval-head > div {
      min-width: 0;
    }
    .retrieval-main {
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .retrieval-top {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      min-width: 0;
    }
    .retrieval-source-line {
      display: flex;
      align-items: baseline;
      gap: 8px;
      min-width: 0;
      flex: 1 1 auto;
    }
    .retrieval-top-meta {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }
    .retrieval-bottom {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      min-width: 0;
    }
    .meta-pill {
      border: 1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: inherit;
      line-height: 1.2;
      white-space: nowrap;
    }
    .retrieval-pages {
      color: var(--text);
      font-size: inherit;
      white-space: nowrap;
      flex: 0 0 auto;
    }
    .retrieval-source {
      flex: 0 1 auto;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .retrieval-section {
      flex: 1 1 auto;
      min-width: 0;
      white-space: normal;
      overflow: hidden;
      overflow-wrap: anywhere;
      line-height: 1.2;
      font-size: 12px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .retrieval-actions {
      display: flex;
      gap: 8px;
      align-items: flex-start;
      justify-content: flex-end;
      padding-top: 2px;
    }
    .retrieval-body {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,.08);
      display: grid;
      gap: 10px;
    }
    .retrieval-snippet {
      color: var(--muted);
      font-size: 11px;
      line-height: 1.4;
      overflow-wrap: anywhere;
    }
    .warn { color: var(--danger); font-size: 12px; }
    .warn-box {
      margin: 12px 0 16px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(239,68,68,.35);
      background: rgba(239,68,68,.10);
      color: #fecaca;
      font-size: 13px;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    .table-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin: 0;
    }
    .table-controls .left { display: flex; gap: 10px; align-items: center; }
    .range { width: clamp(120px, 22vw, 220px); }

    /* Responsive tweaks */
    @media (max-width: 900px) {
      :root { --panel-offset: 320px; }
      .header { flex-wrap: wrap; }
      .title h1 { white-space: normal; font-size: clamp(26px, 6vw, 40px); }
      .subtitle { font-size: clamp(14px, 3.5vw, 18px); text-indent: 0; }
      .logo-wrap.logo-right { width: 100%; max-width: 100%; margin-left: 0; justify-content: flex-start; }
      .logo.logo-plain { max-width: 100%; max-height: 130px; object-position: left center; }
    }
    @media (max-width: 520px) {
      :root { --panel-offset: 360px; }
      .app { padding: 12px; }
      .card .card-h { padding: 12px 12px; }
      .subtitle { margin-top: 6px; }
    }

    /* Time range buttons */
    .time-range-section {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }
    .btn-secondary {
      background: rgba(255,255,255,.06);
      border: 1px solid var(--border);
      color: var(--text);
      font-weight: 500;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
      transition: .15s ease;
    }
    .btn-secondary:hover {
      border-color: rgba(255,255,255,.35);
      background: rgba(255,255,255,.10);
    }
    .btn-secondary:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    .btn-secondary.active {
      border-color: var(--accent);
      background: rgba(34,197,94,.15);
    }

    /* Filter section */
    .filter-section {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(0,0,0,.12);
      margin-bottom: 10px;
    }
    .filter-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    .filter-row.full {
      grid-template-columns: 1fr;
    }
    .filter-group label {
      margin: 0 0 4px;
    }
    .tag-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }
    .tag-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
      cursor: pointer;
    }
    .tag-checkbox input {
      width: auto;
      margin: 0;
    }

    /* Class legend */
    details.legend {
      margin-top: 10px;
      font-size: 12px;
    }
    details.legend summary {
      cursor: pointer;
      color: var(--muted);
      user-select: none;
    }
    details.legend summary:hover {
      color: var(--text);
    }
    .legend-table {
      margin-top: 8px;
      width: 100%;
      border-collapse: collapse;
    }
    .legend-table td {
      padding: 4px 8px;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }
    .legend-table td:first-child {
      font-family: var(--mono);
      color: var(--accent-2);
      white-space: nowrap;
    }

    /* SCADA toggle */
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,.15);
      border-radius: 24px;
      transition: .2s;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: var(--text);
      border-radius: 50%;
      transition: .2s;
    }
    .toggle-switch input:checked + .toggle-slider {
      background: var(--accent);
    }
    .toggle-row.is-pending .toggle-switch input:checked + .toggle-slider {
      background: rgba(148,163,184,.65);
    }
    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    .scada-section {
      transition: max-height .3s ease, opacity .2s ease;
      max-height: 1200px;
      overflow: hidden;
    }
    .scada-section.collapsed {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .scada-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 12px;
    }
    .toggle-row-actions {
      flex-wrap: wrap;
    }
    .reselect-row {
      display: none;
      margin-left: auto;
    }
    .reselect-row.is-visible {
      display: inline-flex;
    }
    .btn-subtle {
      background: rgba(255,255,255,.06);
      border: 1px solid var(--border);
      color: var(--muted);
    }
    .btn-subtle:hover {
      border-color: rgba(255,255,255,.35);
      color: var(--text);
    }
    .mock-image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .mock-image-item {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      overflow: hidden;
      cursor: pointer;
      transition: border-color .15s ease, box-shadow .15s ease;
    }
    .mock-image-item:hover {
      border-color: rgba(255,255,255,.35);
    }
    .mock-image-item.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(34,197,94,.2);
    }
    .mock-image-item img {
      width: 100%;
      height: 92px;
      object-fit: cover;
      display: block;
    }
    .mock-image-name {
      font-size: 11px;
      padding: 6px 8px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .mock-image-check {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.4);
    }
    .mock-image-item.selected .mock-image-check {
      background: var(--accent);
      border-color: var(--accent);
    }
    .image-overlay .card-b {
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .image-mock-section {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      max-height: none;
    }
    .image-mock-section .mock-image-grid {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 4px;
    }

    /* SCADA card list */
    .scada-card-list {
      max-height: 280px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,.12);
    }
    .scada-card-item {
      display: grid;
      grid-template-columns: 24px 140px 1fr;
      gap: 8px;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background .1s;
      font-size: 12px;
    }
    .scada-card-item:last-child {
      border-bottom: none;
    }
    .scada-card-item:hover {
      background: rgba(255,255,255,.04);
    }
    .scada-card-item.selected {
      background: rgba(34,197,94,.12);
      border-color: var(--accent);
    }
    .scada-card-item input[type="radio"] {
      width: 16px;
      height: 16px;
      margin: 0;
      accent-color: var(--accent);
    }
    .scada-card-id {
      font-family: var(--mono);
      color: var(--text);
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .scada-card-class {
      font-family: var(--mono);
      color: var(--accent-2);
      font-size: 11px;
    }
    .scada-card-status {
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-left: 12px;
      border-left: 1px solid var(--border);
    }
    .scada-card-status.anomaly {
      color: var(--danger);
    }
    .scada-card-tags {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      justify-content: flex-start;
      min-width: 100px;
    }
    .scada-card-time {
      color: var(--muted);
      font-size: 10px;
      flex-basis: 100%;
    }
    .scada-card-tag {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(56,189,248,.15);
      color: var(--accent-2);
      white-space: nowrap;
    }
    .scada-card-empty {
      padding: 16px;
      text-align: center;
      color: var(--muted);
      font-size: 12px;
    }
    .scada-list-header {
      display: grid;
      grid-template-columns: 24px 140px 1fr;
      gap: 8px;
      padding: 6px 12px;
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.15);
      position: sticky;
      top: 0;
    }
    .scada-list-header span:last-child {
      padding-left: 12px;
      border-left: 1px solid var(--border);
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title">
        <span class="logo-wrap">
          <img class="logo" src="/static/logo.png" alt="Wind turbine logo" />
        </span>
      <div>
        <h1>Wind Turbine Inspection Assistant</h1>
        <div class="subtitle">Let's inspect wind turbines, but smart!</div>
      </div>
    </div>
      <span class="logo-wrap logo-right">
        <img class="logo logo-plain" src="/static/logo%204.png" alt="Logo 4" />
      </span>
    </div>

    <div id="warnBox" class="warn-box" role="alert" style="display:none"></div>

    <div class="grid">
      <!-- INPUTS -->
      <div class="card inputs-card">
        <div class="card-h" id="inputsHeader">
          <h2>Inputs</h2>
          <button id="runBtn" class="btn btn-inline">Run</button>
        </div>
        <div class="card-b">
          <div class="input-section">
            <div class="input-section-h">Notes</div>
            <label>Mechanic notes </label>
            <textarea id="mechanicNotes" placeholder="e.g., customer report, recent maintenance, observed behavior..."></textarea>
          </div>

          <div class="input-section">
            <div class="input-section-h">Images</div>
            <label>Images Images are used for automatic descriptions.</label>
            <div id="drop" class="drop">
              <b>Drop images here</b><div class="small">or click to select.</div>
              <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
            </div>
            <div class="file-list" id="fileList"></div>
            <div class="toggle-row toggle-row-actions" id="imageMockRow" style="margin-top:8px;">
              <label class="toggle-switch">
                <input type="checkbox" id="imageMockToggle" />
                <span class="toggle-slider"></span>
              </label>
              <span>Mock image data</span>
              <div class="reselect-row" id="reselectImageWrap">
                <button type="button" class="btn btn-subtle btn-inline" id="reselectImageData">Reselect data</button>
              </div>
            </div>
          </div>

          <div class="input-section">
            <div class="input-section-h">SCADA</div>
            <!-- SCADA Toggle -->
            <div class="toggle-row">
              <label class="toggle-switch">
                <input type="checkbox" id="scadaToggle" />
                <span class="toggle-slider"></span>
              </label>
              <span>Include SCADA data</span>
            </div>
            <div class="toggle-row toggle-row-actions" id="mockDataRow" style="margin-top:8px;">
              <label class="toggle-switch">
                <input type="checkbox" id="mockDataToggle" />
                <span class="toggle-slider"></span>
              </label>
              <span>Mock data</span>
              <div class="reselect-row" id="reselectScadaWrap">
                <button type="button" class="btn btn-subtle btn-inline" id="reselectScadaData">Reselect data</button>
              </div>
            </div>
            <label>SCADA time range (simulated)</label>
            <div class="time-range-section">
              <button type="button" class="btn-secondary" id="btnLast6h" disabled title="Simulated: No live SCADA data available">
                Last 6 Hours
              </button>
              <button type="button" class="btn-secondary" id="btnCustomTime" disabled title="Simulated: No live SCADA data available">
                Custom Time
              </button>
              <input type="datetime-local" id="customTimeInput" disabled style="flex: 1; min-width: 180px;" />
            </div>
            <div class="small" style="margin-bottom: 12px; color: var(--muted);">
              ⚠️ Above buttons simulate real-world usage. For testing, please mock the data.
          </div>
          </div>

          <div class="small" style="margin-top:10px;">
            Hint: Retrieval is biased toward procedures, checklists, and safety content.
          </div>
        </div>
        <div class="card scada-overlay" id="scadaOverlay">
          <div class="card-h">
            <h2>Mock data</h2>
          </div>
          <div class="card-b">
            <div id="scadaSection" class="scada-section collapsed">
              <!-- SCADA Card Selection with Filters -->
              <label>Select SCADA card for testing</label>
              <div class="filter-section">
                <div class="filter-group">
                  <label>Filter by tags</label>
                  <div class="tag-checkboxes" id="tagCheckboxes">
                    <!-- Populated by JS -->
                  </div>
                </div>
              </div>

              <label>Available SCADA cards (<span id="cardCount">0</span> matching)</label>
              <div class="scada-card-list" id="scadaCardList">
                <div class="scada-list-header">
                  <span></span>
                  <span>ID</span>
                  <span>Tags</span>
                </div>
                <!-- Cards populated by JS -->
              </div>
              <input type="hidden" id="scadaSelect" />
              <div class="small" id="scadaPreview" style="margin-top:6px;"></div>
              <div class="scada-actions">
                <button type="button" class="btn-secondary" id="cancelMockData">Cancel</button>
                <button type="button" class="btn btn-inline" id="confirmScadaSelection">Confirm selection</button>
              </div>
            </div><!-- end scadaSection -->
          </div>
        </div>
        <div class="card image-overlay" id="imageOverlay">
          <div class="card-h">
            <h2>Mock images</h2>
          </div>
          <div class="card-b">
            <div id="imageMockSection" class="scada-section collapsed image-mock-section">
              <label>Image set</label>
              <div class="btn-row">
                <button type="button" class="btn-secondary active" id="imageSetUnlabeled">Unlabeled</button>
                <button type="button" class="btn-secondary" id="imageSetLabeled">Labeled</button>
              </div>
              <div class="small" id="imageLabeledDisclaimer" style="margin-top:6px; display:none;">
                Labeled data simulates images labeled by a model (e.g., YOLO) after upload. We did not implement this;
                we use pre-labeled images instead.
              </div>
              <div class="small" id="imageMockCount" style="margin-top:6px;">0 selected</div>
              <div class="mock-image-grid" id="mockImageGrid"></div>
              <div class="scada-actions">
                <button type="button" class="btn-secondary" id="cancelImageMock">Cancel</button>
                <button type="button" class="btn btn-inline" id="confirmImageSelection">Confirm selection</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- OUTPUTS -->
      <div class="card conversation-card">
      <div class="card-h">
        <h2>Conversation</h2>
        <div class="btn-row">
          <div class="inspect-indicator" id="inspectIndicator" style="display:none">
            <span class="spinner"></span>
            Inspecting image
          </div>
        </div>
      </div>
      <div class="card-b chat-wrap" id="chatWrap">
        <div class="small disclaimer">This recommendation is AI-generated and may be inaccurate. Please verify before use.</div>
        <div class="processing-hint" id="processingHint" aria-live="polite">
          <span class="spinner"></span>
          Processing request…
        </div>
        <div class="current-input" id="currentInput" style="display:none;">
          <div class="panel-h">
            <div class="label">Incident input</div>
            <button class="collapse-btn" type="button" data-target="currentInputBody" aria-label="Collapse"></button>
          </div>
          <div id="currentInputBody" class="panel-body"></div>
        </div>
        <div class="current-reco" id="currentReco" style="display:none;">
          <div class="panel-h">
            <div class="label">Recommendation</div>
            <button class="collapse-btn" type="button" data-target="currentRecoBody" aria-label="Collapse"></button>
          </div>
          <div id="currentRecoBody" class="panel-body"></div>
        </div>
        <div class="chat" id="chat"></div>

        </div>
      </div>

      <!-- RETRIEVAL -->
      <div class="card manuals-card">
        <div class="card-h">
          <h2>Top Retrieved Manuals</h2>
          <div class="table-controls">
            <div class="left">
              <span class="small">Show</span>
              <input class="range" id="rangeRows" type="range" min="1" max="10" value="10" />
              <span class="pill" id="rangeLabel">10</span>
            </div>
          </div>
          <button class="collapse-btn" type="button" data-target="retrievalBody" aria-label="Collapse"></button>
        </div>
        <div class="card-b panel-body retrieval-wrap" id="retrievalBody" style="padding:0;">
          <div class="retrieval-list" id="resultsList"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  const state = {
    files: [], // {name, desc, data_url, use}
    scadaOptions: [],
    allScadaCards: [],  // All loaded SCADA cards
    filteredScadaCards: [],  // Cards after filtering
    allTags: [],  // All available tags
    allClasses: [],  // All available classes
    mockDataConfirmed: false,
    mockDataPending: false,
    mockImageConfirmed: false,
    mockImagePending: false,
    mockImageDataset: "unlabeled",
    mockImageOptions: [],
    mockImageSelected: new Set(),
    hasApiKey: true,
    isRunning: false,
    lastResults: [],
    reviewMessage: null,
    incidentCounter: 0,
    inspectingImageId: null,
    lastDiagnosisHtml: "",
    lastDiagnosisRiskCode: null,
    lastDiagnosisMessage: null,
    runToken: 0,
    apiKeyWarning: "",
    chunkTextCache: {},
  };

  function el(id){ return document.getElementById(id); }


  function setStatus(text){
    const pill = el('statusPill');
    if (!pill) {
      return;
    }
    pill.textContent = text;
  }

  function setInspecting(isInspecting){
    const indicator = el('inspectIndicator');
    if (!indicator) {
      return;
    }
    indicator.style.display = isInspecting ? 'inline-flex' : 'none';
  }

  function moveConversationItemToTop(node){
    const chat = el('chat');
    const chatWrap = el('chatWrap');
    if (!node || !chat) {
      return;
    }
    chat.prepend(node);
    if (chatWrap) {
      chatWrap.scrollTop = 0;
    }
  }

  function moveInputToTop(){
    const wrap = el('currentInput');
    if (!wrap || wrap.style.display === 'none') {
      return;
    }
    moveConversationItemToTop(wrap);
  }

  function updateChatMetrics(){
    const chat = el('chat');
    const chatWrap = el('chatWrap');
    const heightSource = chatWrap || chat;
    if (chat && heightSource) {
      chat.style.setProperty('--chat-body-height', `${heightSource.clientHeight}px`);
    }

    const grid = document.querySelector('.grid');
    const app = document.querySelector('.app');
    if (!grid || !app) {
      return;
    }
    const gridTop = grid.getBoundingClientRect().top;
    const appStyles = window.getComputedStyle(app);
    const paddingBottom = parseFloat(appStyles.paddingBottom) || 0;
    const available = Math.max(0, Math.floor(window.innerHeight - gridTop - paddingBottom - 1));
    document.documentElement.style.setProperty('--panel-height', `${available}px`);

    const inputsHeader = el('inputsHeader');
    if (inputsHeader) {
      const headerHeight = Math.ceil(inputsHeader.getBoundingClientRect().height);
      document.documentElement.style.setProperty('--card-h-height', `${headerHeight}px`);
    }
  }

  function setRunning(isRunning){
    document.body.classList.toggle("is-running", !!isRunning);
    document.body.setAttribute("aria-busy", isRunning ? "true" : "false");
    const logo = document.querySelector(".logo");
    if (!logo) {
      return;
    }
    if (isRunning) {
      logo.classList.remove("is-spinning");
      void logo.offsetWidth;
      logo.classList.add("is-spinning");
      startFaviconSpin();
    } else {
      logo.classList.remove("is-spinning");
      stopFaviconSpin();
    }
    state.isRunning = !!isRunning;
    updateRunButtonAvailability();
  }

  function updateRunButtonAvailability(){
    const runBtn = el('runBtn');
    if (!runBtn) {
      return;
    }
    const blockedByApi = !state.hasApiKey;
    const blockedByPending = state.mockDataPending || state.mockImagePending;
    const blockedByRunning = state.isRunning;
    const shouldDisable = blockedByApi || blockedByPending || blockedByRunning;
    runBtn.disabled = shouldDisable;
    runBtn.classList.toggle('is-muted', blockedByPending);
    runBtn.title = blockedByApi ? state.apiKeyWarning : '';
  }

  function showWarn(msg){
    const box = el('warnBox');
    if (!box) {
      return;
    }
    const text = msg || state.apiKeyWarning || '';
    box.style.display = text ? 'block' : 'none';
    box.textContent = text;
  }

  async function checkApiKeyStatus(){
    try {
      const resp = await fetch('/api/status');
      if (!resp.ok) {
        return;
      }
      const data = await resp.json();
      const hasKey = !!data?.openai_api_key_set;
      state.apiKeyWarning = hasKey ? "" : String(data?.warning || "OPENAI_API_KEY is not set. See README.md in the repository root.");
      state.hasApiKey = hasKey;
      updateRunButtonAvailability();

      showWarn('');
    } catch (e) {
      return;
    }
  }

  function setCurrentInput(text){
    const wrap = el('currentInput');
    const body = el('currentInputBody');
    if (!wrap || !body) {
      return;
    }
    const safe = escapeHtml(text || '').replace(/\n/g, '<br>');
    if (!safe.trim()) {
      wrap.style.display = 'none';
      body.innerHTML = '';
      updateChatMetrics();
      return;
    }
    wrap.style.display = 'block';
    body.innerHTML = safe;
    body.classList.remove("collapsed");
    if (wrap.dataset.runToken !== String(state.runToken)) {
      moveConversationItemToTop(wrap);
      wrap.dataset.runToken = String(state.runToken);
    }
    updateChatMetrics();
  }

  function setCurrentRecommendation(htmlText, isLoading){
    const wrap = el("currentReco");
    const body = el("currentRecoBody");
    if (!wrap || !body) {
      return;
    }
    if (!htmlText) {
      wrap.style.display = "none";
      body.innerHTML = "";
      updateChatMetrics();
      return;
    }
    wrap.style.display = "block";
    body.innerHTML = isLoading ? `<span class="spinner"></span> ${htmlText}` : htmlText;
    body.classList.remove("collapsed");
    if (wrap.dataset.runToken !== String(state.runToken)) {
      moveConversationItemToTop(wrap);
      wrap.dataset.runToken = String(state.runToken);
    }
    updateChatMetrics();
  }

  function archiveCurrentCase(){
    const inputBody = el("currentInputBody");
    const recoBody = el("currentRecoBody");
    const inputHtml = inputBody ? inputBody.innerHTML.trim() : "";
    const recoHtml = recoBody ? recoBody.innerHTML.trim() : "";
    const diagHtml = (state.lastDiagnosisHtml || "").trim();
    if (!inputHtml && !recoHtml && !diagHtml) {
      return;
    }

    state.incidentCounter += 1;
    const parts = [];
    if (inputHtml) {
      parts.push(`<strong>Incident input</strong><br>${inputHtml}`);
    }
    if (diagHtml) {
      const riskHtml = renderRiskPillHtml(state.lastDiagnosisRiskCode);
      parts.push(`<strong>Diagnosis</strong><br>${riskHtml}<br>${diagHtml}`);
    }
    const imageItems = (state.files || []).filter((f) => f && f.data_url);
    if (imageItems.length) {
      const imagesHtml = imageItems.map((f) => `
        <div class="archive-image">
          <img src="${f.data_url}" alt="${escapeHtml(f.name || "uploaded image")}" />
          <div class="archive-image-name">${escapeHtml(f.name || "uploaded image")}</div>
        </div>
      `).join("");
      parts.push(`<strong>Uploaded images</strong><br><div class="archive-image-grid">${imagesHtml}</div>`);
    }
    if (recoHtml) {
      parts.push(`<strong>Recommendation</strong><br>${recoHtml}`);
    }
    const wrap = addChatMessage(
      "assistant",
      `Previous incident ${state.incidentCounter}`,
      parts.join("<br><br>"),
      { prepend: true }
    );
    wrap.classList.add("collapsed");
    const btn = wrap.querySelector(".collapse-btn");
    if (btn) {
      btn.classList.add("is-collapsed");
      btn.setAttribute("aria-label", "Expand");
    }
    document.querySelectorAll(".msg.has-image").forEach((msg) => msg.remove());
    state.lastDiagnosisHtml = "";
    state.lastDiagnosisRiskCode = null;
    if (state.lastDiagnosisMessage && state.lastDiagnosisMessage.isConnected) {
      state.lastDiagnosisMessage.remove();
    }
    state.lastDiagnosisMessage = null;
  }

  function addChatMessage(role, title, body, opts){
    const chat = el('chat');
    const chatWrap = el('chatWrap');
    const wrap = document.createElement('div');
    wrap.className = 'msg';
    wrap.innerHTML = `
      <div class="m-h">
        <div class="left">
          <span>${title}</span>
        </div>
        <div class="right">
          <button class="collapse-btn" type="button" aria-label="Collapse"></button>
        </div>
      </div>
      <div class="m-b" id="msg_${Date.now()}">${body}</div>
    `;
    const placeTop = opts && typeof opts.prepend === "boolean" ? opts.prepend : true;
    if (placeTop) {
      chat.prepend(wrap);
      if (chatWrap) {
        chatWrap.scrollTop = 0;
      }
    } else {
      chat.appendChild(wrap);
      if (chatWrap) {
        chatWrap.scrollTop = chatWrap.scrollHeight;
      }
    }
    const btn = wrap.querySelector(".collapse-btn");
    if (btn) {
      btn.onclick = () => {
        wrap.classList.toggle("collapsed");
        const isCollapsed = wrap.classList.contains("collapsed");
        btn.classList.toggle("is-collapsed", isCollapsed);
        btn.setAttribute("aria-label", isCollapsed ? "Expand" : "Collapse");
      };
    }
    return wrap;
  }

  function addChatImage(item){
    if (!item || !item.data_url) {
      return;
    }
    const body = `
      <div class="chat-image">
        <img src="${item.data_url}" alt="${escapeHtml(item.name || "uploaded image")}" />
        <div class="chat-details">
          <div class="caption">${escapeHtml(item.name || "uploaded image")}</div>
          <div class="label">Description</div>
          <div class="caption image-desc" data-image-id="${escapeHtml(item.id)}">
            ${escapeHtml(item.desc || "")}
          </div>
          <div class="inspect-inline">
            <button class="btn-mini inspect-btn" data-image-id="${escapeHtml(item.id)}">Inspect image</button>
            <button class="btn-mini accept-btn" data-image-id="${escapeHtml(item.id)}" style="display:none">Accept</button>
            <button class="btn-mini reject-btn" data-image-id="${escapeHtml(item.id)}" style="display:none">Reject</button>
            <button class="btn-mini decision-btn" data-image-id="${escapeHtml(item.id)}" style="display:none">Change</button>
            <span class="inspect-status">Not inspected</span>
          </div>
        </div>
      </div>
    `;
    const wrap = addChatMessage("user", "Uploaded image", body);
    wrap.classList.add("has-image");
    item.messageEl = wrap;
    const btn = wrap.querySelector(".inspect-btn");
    if (btn) {
      btn.onclick = () => inspectOrEditImage(item.id);
    }
    const acceptBtn = wrap.querySelector(".accept-btn");
    if (acceptBtn) {
      acceptBtn.onclick = () => acceptImage(item.id);
    }
    const rejectBtn = wrap.querySelector(".reject-btn");
    if (rejectBtn) {
      rejectBtn.onclick = () => rejectImage(item.id);
    }
    const decisionBtn = wrap.querySelector(".decision-btn");
    if (decisionBtn) {
      decisionBtn.onclick = () => toggleDecision(item.id);
    }
    updateInspectStatus();
  }

  function renderFileList(){
    const list = el('fileList');
    if (!list) {
      return;
    }
    list.innerHTML = '';

    if(state.files.length === 0){
      const empty = document.createElement('div');
      empty.className = 'small';
      empty.textContent = 'No images added.';
      list.appendChild(empty);
      return;
    }

    state.files.forEach((f, idx) => {
      const item = document.createElement('div');
      item.className = `file-item${f.use === false ? ' is-ignored' : ''}`;
      item.innerHTML = `
        <div class="file-head">
          <div class="file-name">${f.name || 'image'}</div>
          <button class="btn-mini" data-idx="${idx}">Remove</button>
        </div>
      `;
      item.querySelector('button').onclick = () => {
        const target = state.files[idx];
        if (target && !target.inspected && target.messageEl && target.messageEl.isConnected) {
          target.messageEl.remove();
        }
        state.files.splice(idx, 1);
        state.reviewTargetId = null;
        renderFileList();
        updateInspectStatus();
      };
      list.appendChild(item);
    });
  }

  function renderImageReview(){
    if (state.reviewMessage) {
      state.reviewMessage.remove();
      state.reviewMessage = null;
    }

    const wrap = addChatMessage("assistant", "Image Review", "");
    state.reviewMessage = wrap;
    const body = wrap.querySelector(".m-b");
    if (!body) {
      return;
    }
    body.innerHTML = "";

    const review = document.createElement("div");
    review.className = "image-review";

    const grid = document.createElement("div");
    grid.className = "image-grid";

    state.files.forEach((f, idx) => {
      if (!f.data_url) {
        return;
      }
      if (state.reviewTargetId && f.id !== state.reviewTargetId) {
        return;
      }
      if (typeof f.use === "undefined") {
        f.use = true;
      }

      const card = document.createElement("div");
      card.className = `image-card${f.use === false ? " is-ignored" : ""}`;

      const img = document.createElement("img");
      img.className = "image-preview";
      img.src = f.data_url;
      img.alt = f.name || "uploaded image";

      const meta = document.createElement("div");
      meta.className = "image-meta";

      const name = document.createElement("div");
      name.className = "image-name";
      name.textContent = f.name || "uploaded image";

      const label = document.createElement("label");
      label.textContent = "Description";

      const textarea = document.createElement("textarea");
      textarea.value = f.desc || "";
      textarea.disabled = f.use === false;
      textarea.oninput = (e) => {
        state.files[idx].desc = e.target.value;
      };

      const actions = document.createElement("div");
      actions.className = "image-actions";

      const toggle = document.createElement("button");
      toggle.className = "btn-mini";
      toggle.textContent = f.use === false ? "Use" : "Ignore";
      toggle.onclick = () => {
        f.use = f.use === false ? true : false;
        card.classList.toggle("is-ignored", f.use === false);
        toggle.textContent = f.use === false ? "Use" : "Ignore";
        textarea.disabled = f.use === false;
        renderFileList();
      };

      actions.appendChild(toggle);
      meta.appendChild(name);
      meta.appendChild(label);
      meta.appendChild(textarea);
      meta.appendChild(actions);
      card.appendChild(img);
      card.appendChild(meta);
      grid.appendChild(card);
    });

    review.appendChild(grid);

    const actionRow = document.createElement("div");
    actionRow.className = "btn-row";

    const confirmBtn = document.createElement("button");
    confirmBtn.className = "btn";
    confirmBtn.textContent = "Accept image";
    confirmBtn.onclick = () => {
      if (state.reviewMessage) {
        state.reviewMessage.remove();
        state.reviewMessage = null;
      }
      const target = state.files.find((f) => f.id === state.reviewTargetId);
      if (target) {
        target.approved = true;
        target.inspected = true;
      }
      showWarn("");
      setStatus("idle");
      updateInspectStatus();
    };

    const rejectBtn = document.createElement("button");
    rejectBtn.className = "btn-mini";
    rejectBtn.textContent = "Reject Images";
    rejectBtn.onclick = () => {
      const target = state.files.find((f) => f.id === state.reviewTargetId);
      if (target) {
        target.use = false;
        target.desc = "";
        target.approved = false;
        target.inspected = true;
      }
      renderFileList();
      if (state.reviewMessage) {
        state.reviewMessage.remove();
        state.reviewMessage = null;
      }
      showWarn("");
      setStatus("idle");
      updateInspectStatus();
    };

    actionRow.appendChild(confirmBtn);
    actionRow.appendChild(rejectBtn);
    review.appendChild(actionRow);
    body.appendChild(review);
    updateInspectStatus();
  }

  function escapeHtml(str){
    return (str || '')
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  const RISK_LABELS = {
    high_risk: "High risk",
    medium_risk: "Medium risk",
    low_risk: "Low risk",
    no_risk: "No risk",
    not_classified: "Not classified",
  };
  const VALID_RISK_CODES = new Set(Object.keys(RISK_LABELS));

  function normalizeRiskCode(code){
    const raw = String(code || "").trim();
    if (!raw) {
      return "not_classified";
    }
    if (VALID_RISK_CODES.has(raw)) {
      return raw;
    }
    const normalized = raw.toLowerCase().replace(/\s+/g, "_");
    if (VALID_RISK_CODES.has(normalized)) {
      return normalized;
    }
    return "not_classified";
  }

  function renderRiskPillHtml(code){
    const safeCode = normalizeRiskCode(code);
    const label = RISK_LABELS[safeCode] || RISK_LABELS.not_classified;
    return `<span class="risk-pill ${safeCode}">${escapeHtml(label)}</span>`;
  }

  function setMessageRiskPill(messageWrap, code){
    if (!messageWrap) {
      return;
    }
    const safeCode = normalizeRiskCode(code);
    const label = RISK_LABELS[safeCode] || RISK_LABELS.not_classified;

    const right = messageWrap.querySelector(".m-h .right");
    if (!right) {
      return;
    }
    const rolePill = right.querySelector(".pill");
    const collapseBtn = right.querySelector(".collapse-btn");

    let pill = messageWrap.querySelector(".risk-pill");
    if (!pill) {
      pill = document.createElement("span");
      pill.className = "risk-pill";
      if (rolePill) {
        right.insertBefore(pill, rolePill);
      } else if (collapseBtn) {
        right.insertBefore(pill, collapseBtn);
      } else {
        right.appendChild(pill);
      }
    }
    pill.className = `risk-pill ${safeCode}`;
    pill.textContent = label;
  }

  function renderMarkdownSimple(text){
    const lines = (text || "").split(/\r?\n/);
    let html = "";
    let inOl = false;
    let inUl = false;
    let olIndex = 0;

    const closeLists = () => {
      if (inOl) {
        html += "</ol>";
        inOl = false;
      }
      if (inUl) {
        html += "</ul>";
        inUl = false;
      }
    };

    lines.forEach((rawLine) => {
      const line = rawLine.trim();
      if (!line) {
        closeLists();
        html += "<br>";
        return;
      }

      if (line.startsWith("### ")) {
        closeLists();
        html += `<h3>${escapeHtml(line.slice(4))}</h3>`;
        return;
      }
      if (line.startsWith("#### ")) {
        closeLists();
        html += `<h4>${escapeHtml(line.slice(5))}</h4>`;
        return;
      }

      const olMatch = line.match(/^(\d+)\.\s+(.*)$/);
      if (olMatch) {
        if (!inOl) {
          closeLists();
          html += "<ol>";
          inOl = true;
          olIndex = 0;
        }
        const num = parseInt(olMatch[1], 10);
        if (num === 1) {
          olIndex += 1;
        } else {
          olIndex = num;
        }
        const itemText = escapeHtml(olMatch[2]).replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
        html += `<li value="${olIndex}">${itemText}</li>`;
        return;
      }

      const ulMatch = line.match(/^-+\s+(.*)$/);
      if (ulMatch) {
        if (!inUl) {
          closeLists();
          html += "<ul>";
          inUl = true;
        }
        const itemText = escapeHtml(ulMatch[1]).replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
        html += `<li>${itemText}</li>`;
        return;
      }

      closeLists();
      const withBold = escapeHtml(line).replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
      html += `<p>${withBold}</p>`;
    });

    closeLists();
    return html;
  }

  function normalizeDescription(text){
    const raw = (text || "").trim();
    if (!raw) {
      return "";
    }
    if (raw.startsWith("{") && raw.endsWith("}")) {
      try {
        const obj = JSON.parse(raw);
        if (obj && typeof obj.description === "string") {
          return obj.description.trim();
        }
      } catch (e) {
        return raw;
      }
    }
    return raw;
  }

  function formatScadaTimestamp(raw){
    const text = String(raw || "").trim();
    if (!text) {
      return "";
    }
    const match = text.match(/^(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2})/);
    if (match) {
      return `${match[1]} ${match[2]}`;
    }
    return text;
  }

  function formatScadaDateTimeLocal(raw){
    const text = String(raw || "").trim();
    if (!text) {
      return "";
    }
    const match = text.match(/^(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2})/);
    if (match) {
      return `${match[1]}T${match[2]}`;
    }
    const parsed = new Date(text);
    if (!Number.isNaN(parsed.getTime())) {
      return formatDateTimeLocal(parsed);
    }
    return "";
  }

  function formatDateTimeLocal(date){
    const pad = (value) => String(value).padStart(2, "0");
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
  }

  const faviconState = {
    timer: null,
    angle: 0,
    img: null,
    canvas: null,
    ctx: null,
    rafId: null,
    lastTs: 0,
  };
  const FAVICON_SIZE = 64;
  const FAVICON_SCALE = 1;
  const FAVICON_SPIN_RATE = Math.PI * 2 * 0.9;

  function ensureFaviconLink(){
    let link = document.getElementById("appFavicon");
    if (!link) {
      link = document.createElement("link");
      link.rel = "icon";
      link.type = "image/png";
      link.id = "appFavicon";
      document.head.appendChild(link);
    }
    return link;
  }

  function setFaviconHref(href){
    const link = ensureFaviconLink();
    link.href = href;
  }

  function ensureFaviconCanvas(){
    if (!faviconState.canvas) {
      const canvas = document.createElement("canvas");
      canvas.width = FAVICON_SIZE;
      canvas.height = FAVICON_SIZE;
      faviconState.canvas = canvas;
      faviconState.ctx = canvas.getContext("2d");
    }
    return { canvas: faviconState.canvas, ctx: faviconState.ctx };
  }

  function ensureFaviconImage(){
    if (!faviconState.img) {
      const img = new Image();
      img.src = "/static/logo_tab_2.png";
      faviconState.img = img;
    }
    return faviconState.img;
  }

  function drawFaviconFrame(angle){
    const { canvas, ctx } = ensureFaviconCanvas();
    const img = ensureFaviconImage();
    if (!ctx || !canvas || !img.complete || img.naturalWidth === 0) {
      return false;
    }
    const size = canvas.width * FAVICON_SCALE;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    if (angle) {
      ctx.rotate(angle);
    }
    ctx.drawImage(img, -size / 2, -size / 2, size, size);
    ctx.restore();
    setFaviconHref(canvas.toDataURL("image/png"));
    return true;
  }

  function renderFaviconStatic(){
    if (drawFaviconFrame(0)) {
      return;
    }
    const img = ensureFaviconImage();
    img.addEventListener("load", () => drawFaviconFrame(0), { once: true });
  }

  function startFaviconSpin(){
    if (faviconState.timer || faviconState.rafId) {
      return;
    }
    const img = ensureFaviconImage();
    const startTimer = () => {
      if (faviconState.rafId) {
        return;
      }
      const { canvas, ctx } = ensureFaviconCanvas();
      const tick = (ts) => {
        if (!ctx || !canvas) {
          faviconState.rafId = null;
          return;
        }
        if (!faviconState.lastTs) {
          faviconState.lastTs = ts;
        }
        const delta = (ts - faviconState.lastTs) / 1000;
        faviconState.lastTs = ts;
        faviconState.angle = (faviconState.angle + FAVICON_SPIN_RATE * delta) % (Math.PI * 2);
        drawFaviconFrame(faviconState.angle);
        faviconState.rafId = window.requestAnimationFrame(tick);
      };
      faviconState.rafId = window.requestAnimationFrame(tick);
    };

    if (img.complete && img.naturalWidth > 0) {
      startTimer();
      return;
    }
    img.addEventListener("load", startTimer, { once: true });
    img.addEventListener("error", () => setFaviconHref("/static/logo_tab_2.png"), { once: true });
  }

  function stopFaviconSpin(){
    if (faviconState.timer) {
      clearInterval(faviconState.timer);
      faviconState.timer = null;
    }
    if (faviconState.rafId) {
      cancelAnimationFrame(faviconState.rafId);
      faviconState.rafId = null;
    }
    faviconState.lastTs = 0;
    faviconState.angle = 0;
    renderFaviconStatic();
  }

  async function loadScadaOptions(){
    // Load all SCADA cards from new endpoint
    const resp = await fetch('/api/scada-cards/all');
    if(!resp.ok) throw new Error('Failed to load SCADA cards');
    const data = await resp.json();
    
    state.allScadaCards = data.cards || [];
    state.allTags = data.all_tags || [];
    state.allClasses = data.all_classes || [];
    
    // Populate tag checkboxes
    const tagContainer = el('tagCheckboxes');
    tagContainer.innerHTML = '';
    if (state.allTags.length === 0) {
      tagContainer.innerHTML = '<span class="small">No tags available</span>';
    } else {
      state.allTags.forEach(tag => {
        const label = document.createElement('label');
        label.className = 'tag-checkbox';
        label.innerHTML = `<input type="checkbox" value="${escapeHtml(tag)}" /> ${escapeHtml(tag)}`;
        label.querySelector('input').onchange = applyFilters;
        tagContainer.appendChild(label);
      });
    }
    
    // Initial filter application
    applyFilters();
  }

  function getSelectedTags() {
    const checkboxes = el('tagCheckboxes').querySelectorAll('input[type="checkbox"]:checked');
    return Array.from(checkboxes).map(cb => cb.value);
  }

  function applyFilters() {
    const selectedTags = getSelectedTags();
    
    // Apply tags filtering
    state.filteredScadaCards = state.allScadaCards.filter(card => {
      // Tags filter (AND: card must have ALL selected tags)
      if (selectedTags.length > 0) {
        const cardTags = card.tags || [];
        if (!selectedTags.every(tag => cardTags.includes(tag))) {
          return false;
        }
      }
      
      return true;
    });
    
    // Update card count
    el('cardCount').textContent = state.filteredScadaCards.length;
    
    // Update dropdown
    renderScadaDropdown();
  }

  function renderScadaDropdown() {
    const list = el('scadaCardList');
    const hiddenInput = el('scadaSelect');
    
    // Keep the header, remove other children
    const header = list.querySelector('.scada-list-header');
    list.innerHTML = '';
    if (header) list.appendChild(header);
    
    if (state.filteredScadaCards.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'scada-card-empty';
      empty.textContent = 'No matching cards';
      list.appendChild(empty);
      hiddenInput.value = '';
      el('scadaPreview').textContent = '';
      return;
    }
    
    state.filteredScadaCards.forEach((card, idx) => {
      const item = document.createElement('div');
      item.className = 'scada-card-item' + (idx === 0 ? ' selected' : '');
      item.dataset.cardId = card.id;
      
      // Radio button
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'scadaCard';
      radio.value = card.id;
      radio.checked = idx === 0;
      
      // ID - show full ID
      const idSpan = document.createElement('span');
      idSpan.className = 'scada-card-id';
      idSpan.textContent = card.id;
      idSpan.title = card.id;
      
      // Tags
      const tagsDiv = document.createElement('div');
      tagsDiv.className = 'scada-card-tags';
      (card.tags || []).forEach(tag => {
        const tagSpan = document.createElement('span');
        tagSpan.className = 'scada-card-tag';
        tagSpan.textContent = tag;
        tagsDiv.appendChild(tagSpan);
      });
      const startLabel = formatScadaTimestamp(
        card.window_start || card.case?.window?.start_time || card.case?.source?.window_start
      );
      const endLabel = formatScadaTimestamp(
        card.window_end || card.case?.window?.end_time || card.case?.source?.window_end
      );
      if (startLabel || endLabel) {
        const timeSpan = document.createElement('span');
        timeSpan.className = 'scada-card-time';
        timeSpan.textContent = `${startLabel || '—'} – ${endLabel || '—'}`;
        tagsDiv.appendChild(timeSpan);
      }
      
      item.appendChild(radio);
      item.appendChild(idSpan);
      item.appendChild(tagsDiv);
      
      // Click handler
      item.onclick = () => {
        list.querySelectorAll('.scada-card-item').forEach(i => i.classList.remove('selected'));
        item.classList.add('selected');
        radio.checked = true;
        hiddenInput.value = card.id;
        renderScadaPreview();
      };
      
      list.appendChild(item);
    });
    
    // Set initial value
    hiddenInput.value = state.filteredScadaCards[0]?.id || '';
    renderScadaPreview();
  }

  function renderScadaPreview(){
    const sel = el('scadaSelect');
    const id = sel.value;
    const card = state.filteredScadaCards.find(x => x.id === id);
    if(!card){ el('scadaPreview').textContent = ''; return; }
    
    // Show full description from card case when available
    const description = card.case?.description || card.case?.summary || '';
    el('scadaPreview').textContent = description;
  }

  async function loadMockImages(dataset){
    try {
      const resp = await fetch(`/api/image-selection?dataset=${encodeURIComponent(dataset)}`);
      if (!resp.ok) {
        const data = await resp.json().catch(() => ({}));
        throw new Error(data?.detail || "Failed to load mock images.");
      }
      const data = await resp.json();
      state.mockImageOptions = Array.isArray(data.images) ? data.images : [];
      state.mockImageSelected = new Set();
      renderMockImageGrid();
    } catch (e) {
      showWarn(e.message);
    }
  }

  function updateMockImageSelectionCount(){
    const count = el('imageMockCount');
    if (!count) {
      return;
    }
    count.textContent = `${state.mockImageSelected.size} selected`;
  }

  function renderMockImageGrid(){
    const grid = el('mockImageGrid');
    if (!grid) {
      return;
    }
    grid.innerHTML = '';
    if (!state.mockImageOptions.length) {
      const empty = document.createElement('div');
      empty.className = 'small';
      empty.textContent = 'No images found.';
      grid.appendChild(empty);
      updateMockImageSelectionCount();
      return;
    }
    state.mockImageOptions.forEach((img) => {
      const item = document.createElement('div');
      item.className = `mock-image-item${state.mockImageSelected.has(img.id) ? ' selected' : ''}`;

      const imgEl = document.createElement('img');
      imgEl.src = img.data_url;
      imgEl.alt = img.name || 'mock image';

      const check = document.createElement('div');
      check.className = 'mock-image-check';

      const name = document.createElement('div');
      name.className = 'mock-image-name';
      name.textContent = img.name || 'mock image';

      item.onclick = () => {
        if (state.mockImageSelected.has(img.id)) {
          state.mockImageSelected.delete(img.id);
        } else {
          state.mockImageSelected.add(img.id);
        }
        renderMockImageGrid();
      };

      item.appendChild(imgEl);
      item.appendChild(check);
      item.appendChild(name);
      grid.appendChild(item);
    });
    updateMockImageSelectionCount();
  }

  function clearMockImageSelection(){
    state.mockImageSelected = new Set();
    renderMockImageGrid();
  }

  function removeMockImageFiles(){
    if (!state.files.length) {
      return;
    }
    const removed = state.files.filter((item) => item.mockSource === 'image_selection');
    state.files = state.files.filter((item) => item.mockSource !== 'image_selection');
    removed.forEach((item) => {
      if (item.messageEl && item.messageEl.isConnected) {
        item.messageEl.remove();
      }
    });
    state.reviewTargetId = null;
  }

  function applyMockImageSelection(){
    const selected = state.mockImageOptions.filter((img) => state.mockImageSelected.has(img.id));
    if (!selected.length) {
      showWarn("Select at least one mock image.");
      return false;
    }
    removeMockImageFiles();
    selected.forEach((img, idx) => {
      const item = {
        id: `mock_${Date.now()}_${idx}`,
        name: img.name || 'mock image',
        desc: '',
        data_url: img.data_url,
        use: true,
        inspected: false,
        approved: false,
        mockSource: 'image_selection',
      };
      state.files.push(item);
      addChatImage(item);
    });
    renderFileList();
    updateInspectStatus();
    return true;
  }

  function renderResultsTable(items){
    state.lastResults = items || [];
    const showRowsInput = el('showRows');
    const rangeRowsInput = el('rangeRows');
    const showRaw = (showRowsInput && showRowsInput.value) || (rangeRowsInput && rangeRowsInput.value) || '10';
    const showN = Math.max(1, Math.min(10, parseInt(showRaw, 10)));

    const list = el('resultsList');
    if (!list) {
      return;
    }
    list.innerHTML = '';

    const visible = state.lastResults.slice(0, showN);
    if (!visible.length) {
      const empty = document.createElement('div');
      empty.className = 'small';
      empty.textContent = 'No results yet.';
      list.appendChild(empty);
      return;
    }

    visible.forEach((it, i) => {
      const chunkId = String(it.chunk_id || '');
      const scoreNum = Number(it.score);
      const scoreText = Number.isFinite(scoreNum) ? scoreNum.toFixed(3) : String(it.score ?? '');
      const page = it.page ?? '';
      const pageEnd = it.page_end ?? it.page ?? '';
      const pages = `${page}-${pageEnd}`;
      const sourceRaw = String(it.source || '');
      const sectionRaw = String(it.section || '');
      const snippetRaw = String(it.snippet || '');
      const rankLabel = `Rank ${i + 1}`;
      const scoreLabel = `Score ${scoreText}`;
      const pagesLabel = pages ? `Pages ${pages}` : 'Pages -';
      const sectionLabel = sectionRaw ? `Section: ${sectionRaw}` : 'Section: -';

      const wrap = document.createElement('div');
      wrap.className = 'retrieval-item';
      wrap.innerHTML = `
        <div class="retrieval-head">
          <div class="retrieval-main">
            <div class="retrieval-top">
              <div class="retrieval-source-line">
                <div class="mono retrieval-source" title="${escapeHtml(sourceRaw)}">${escapeHtml(sourceRaw)}</div>
                <div class="mono retrieval-pages">${escapeHtml(pagesLabel)}</div>
              </div>
              <div class="retrieval-top-meta">
                <span class="meta-pill mono">${escapeHtml(rankLabel)}</span>
                <span class="meta-pill mono">${escapeHtml(scoreLabel)}</span>
              </div>
            </div>
            <div class="retrieval-bottom">
              <div class="retrieval-section" title="${escapeHtml(sectionRaw)}">${escapeHtml(sectionLabel)}</div>
            </div>
          </div>
          <div class="retrieval-actions">
            ${chunkId ? `<button type="button" class="btn-mini chunk-toggle">Show text</button>` : ``}
          </div>
        </div>
        <div class="retrieval-body">
          <div class="retrieval-snippet">${escapeHtml(snippetRaw)}</div>
          ${
            chunkId
              ? `<div class="chunk-detail-inner" style="display:none" data-chunk-id="${escapeHtml(chunkId)}">
                  <div class="chunk-detail-actions">
                    <span class="chunk-meta mono">${escapeHtml(chunkId)}</span>
                    <button type="button" class="btn-mini copy-chunk" disabled>Copy</button>
                  </div>
                  <pre class="chunk-text">Loading...</pre>
                </div>`
              : ``
          }
        </div>
      `;

      list.appendChild(wrap);

      if (!chunkId) {
        return;
      }

      const toggleBtn = wrap.querySelector('.chunk-toggle');
      const detail = wrap.querySelector('.chunk-detail-inner');
      const pre = wrap.querySelector('.chunk-text');
      const copyBtn = wrap.querySelector('.copy-chunk');
      if (!toggleBtn || !detail || !pre || !copyBtn) {
        return;
      }

      toggleBtn.onclick = async () => {
        const isOpen = detail.style.display !== 'none';
        if (isOpen) {
          detail.style.display = 'none';
          toggleBtn.textContent = 'Show text';
          return;
        }

        detail.style.display = 'block';
        toggleBtn.textContent = 'Hide text';

        if (detail.dataset.loaded === 'true') {
          return;
        }

        try {
          let cached = state.chunkTextCache[chunkId];
          if (!cached) {
            pre.textContent = 'Loading...';
            const resp = await fetch(`/api/chunk/${encodeURIComponent(chunkId)}`);
            const data = await resp.json();
            if (!resp.ok) {
              throw new Error(data?.detail || 'Failed to load chunk text');
            }
            cached = data;
            state.chunkTextCache[chunkId] = data;
          }

          const text = String(cached?.text || '');
          pre.textContent = text || '(empty)';
          copyBtn.disabled = !text;
          copyBtn.onclick = async () => {
            try {
              await navigator.clipboard.writeText(text);
            } catch (e) {
              return;
            }
          };
          detail.dataset.loaded = 'true';
        } catch (e) {
          pre.textContent = `Failed to load text: ${e.message}`;
          copyBtn.disabled = true;
        }
      };
    });
  }

  async function requestDiagnosis(payload){
    const wrap = addChatMessage(
      "assistant",
      "Diagnosis",
      "<span class=\"spinner\"></span> Generating diagnosis..."
    );
    if (wrap) {
      wrap.classList.add("diagnosis-card");
      const rolePill = wrap.querySelector(".m-h .right .pill");
      if (rolePill) {
        rolePill.remove();
      }
    }
    state.lastDiagnosisMessage = wrap;
    state.lastDiagnosisRiskCode = null;
    setMessageRiskPill(wrap, "not_classified");
    moveInputToTop();
    const body = wrap.querySelector(".m-b");
    try {
      const resp = await fetch('/api/diagnosis', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload),
      });
      const data = await resp.json();
      if (!resp.ok) {
        throw new Error(data?.detail || 'Diagnosis failed');
      }
      const text = data?.diagnosis || '(no diagnosis)';
      const riskCode = normalizeRiskCode(data?.risk_code);
      const safe = escapeHtml(text).replace(/\n/g, '<br>');
      if (body) {
        body.innerHTML = safe;
      }
      state.lastDiagnosisHtml = safe;
      state.lastDiagnosisRiskCode = riskCode;
      setMessageRiskPill(wrap, riskCode);
    } catch (e) {
      const safe = escapeHtml(`Diagnosis error: ${e.message}`);
      if (body) {
        body.innerHTML = safe;
      }
      state.lastDiagnosisHtml = safe;
      state.lastDiagnosisRiskCode = "not_classified";
      setMessageRiskPill(wrap, "not_classified");
    } finally {
      updateChatMetrics();
    }
  }

  async function run(){
    showWarn('');

    let mechanicNotes = el('mechanicNotes').value || '';
    const scadaEnabled = el('scadaToggle').checked;
    const mockDataEnabled = el('mockDataToggle') ? el('mockDataToggle').checked : false;
    let scadaId = scadaEnabled ? el('scadaSelect').value : null;
    const topKInput = el('topK');
    const topKRaw = topKInput ? topKInput.value : '10';
    const topK = Math.max(3, Math.min(30, parseInt(topKRaw, 10)));

    if (state.mockDataPending) {
      showWarn("Confirm mock data selection before running.");
      return;
    }
    if (state.mockImagePending) {
      showWarn("Confirm mock image selection before running.");
      return;
    }
    if (scadaEnabled && !mockDataEnabled) {
      showWarn("Enable mock data to use SCADA data.");
      return;
    }

    const imageDescriptions = state.files
      .filter(f => f.use !== false)
      .map(f => (f.desc || '').trim())
      .filter(Boolean);

    const imageTargets = state.files
      .filter(f => f.use !== false && !!f.data_url);

    const pending = imageTargets.filter((f) => !f.approved);
    if (pending.length) {
      showWarn("Please inspect and accept or reject each image before running.");
      setStatus("confirm");
      updateInspectStatus();
      return;
    }

    setStatus('running');
    setRunning(true);
    state.runToken += 1;

    const imageFiles = imageTargets
      .map(f => ({ name: f.name || 'image', data_url: f.data_url }));

    let placeholder = null;
    try {
      const userSummary = [
        mechanicNotes && `Mechanic notes: ${mechanicNotes}`,
        scadaId && `SCADA: ${scadaId}`,
        imageDescriptions.length && `Images: ${imageDescriptions.join(' | ')}`,
      ].filter(Boolean).join('\n');

      archiveCurrentCase();
      setCurrentInput(userSummary || '');

      setCurrentRecommendation("Thinking...", true);

      // Get SCADA case data from filtered cards (only if enabled)
      const selectedCard = scadaEnabled ? state.filteredScadaCards.find(c => c.id === scadaId) : null;
      const scadaCase = selectedCard?.case || null;

      requestDiagnosis({
        scada_id: scadaId,
        scada_case: scadaCase,
        mechanic_notes: mechanicNotes,
        image_descriptions: imageDescriptions,
      });

      const resp = await fetch('/api/run', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({
          scada_id: scadaId,
          scada_case: scadaCase,
          mechanic_notes: mechanicNotes,
          image_descriptions: imageDescriptions,
          top_k: topK,
        })
      });

      const data = await resp.json();
      if(!resp.ok){
        throw new Error(data?.detail || 'Request failed');
      }

      const rec = data.recommendation_markdown || '(no recommendation)';
      setCurrentRecommendation(renderMarkdownSimple(rec), false);

      renderResultsTable(data.retrieved || []);

    } catch (e) {
      const msg = `Error: ${e.message}`;
      setCurrentRecommendation(escapeHtml(msg), false);
      showWarn(e.message);
    } finally {
      setStatus(state.awaitingConfirm ? 'confirm' : 'idle');
      setRunning(false);
    }
  }

  async function inspectSingleImage(imageId){
    showWarn('');
    const target = state.files.find((f) => f.id === imageId);
    if (!target || !target.data_url) {
      showWarn("No images to inspect.");
      return;
    }
    const imageFiles = [{ name: target.name || "image", data_url: target.data_url }];

    if (!imageFiles.length) {
      showWarn("No images to inspect.");
      return;
    }

    setStatus("inspecting");
    setInspecting(true);
    setRunning(true);
    state.inspectingImageId = imageId;
    updateInspectStatus();
    const hint = el("processingHint");
    if (hint) {
      hint.innerHTML = "<span class=\"spinner\"></span> Inspecting image…";
    }

    try {
      const resp = await fetch("/api/faulty-describe", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ image_files: imageFiles })
      });
      const data = await resp.json();
      if (!resp.ok) {
        throw new Error(data?.detail || "Faulty description failed");
      }

      const descs = data.descriptions || [];
      const d = descs[0];
      if (d && d.description) {
        target.desc = normalizeDescription(d.description);
      }
      target.use = true;
      target.inspected = true;
      target.approved = false;
      state.reviewTargetId = imageId;
      renderFileList();
      setStatus("confirm");
    } catch (e) {
      showWarn(e.message);
      setStatus("idle");
    } finally {
      setRunning(false);
      setInspecting(false);
      state.inspectingImageId = null;
      if (hint) {
        hint.innerHTML = "<span class=\"spinner\"></span> Processing request…";
      }
      updateInspectStatus();
    }
  }

  function inspectOrEditImage(imageId){
    const target = state.files.find((f) => f.id === imageId);
    if (!target) {
      return;
    }
    if (target.inspected) {
      editImageDescription(imageId);
      return;
    }
    inspectSingleImage(imageId);
  }

  function editImageDescription(imageId){
    const target = state.files.find((f) => f.id === imageId);
    if (!target) {
      return;
    }
    const current = target.desc || "";
    const next = window.prompt("Edit description", current);
    if (next === null) {
      return;
    }
    target.desc = next.trim();
    updateInspectStatus();
  }

  function acceptImage(imageId){
    const target = state.files.find((f) => f.id === imageId);
    if (!target) {
      return;
    }
    target.use = true;
    target.approved = true;
    target.inspected = true;
    renderFileList();
    showWarn("");
    setStatus("idle");
    updateInspectStatus();
  }

  function rejectImage(imageId){
    const target = state.files.find((f) => f.id === imageId);
    if (!target) {
      return;
    }
    target.use = false;
    target.approved = false;
    target.inspected = true;
    renderFileList();
    showWarn("");
    setStatus("idle");
    updateInspectStatus();
  }

  function toggleDecision(imageId){
    const target = state.files.find((f) => f.id === imageId);
    if (!target) {
      return;
    }
    if (target.approved) {
      target.approved = false;
      target.use = false;
    } else {
      target.approved = true;
      target.use = true;
    }
    target.inspected = true;
    renderFileList();
    updateInspectStatus();
  }

  function updateInspectStatus(){
    document.querySelectorAll(".inspect-btn").forEach((btn) => {
      const imageId = btn.getAttribute("data-image-id");
      const item = state.files.find((f) => f.id === imageId);
      const inspected = !!item?.inspected;
      const isLoading = state.inspectingImageId === imageId;
      btn.classList.toggle("is-loading", isLoading);
      if (isLoading) {
        btn.innerHTML = "<span class=\"spinner\"></span> Inspecting";
        btn.disabled = true;
        return;
      }
      btn.textContent = inspected ? "Edit manually" : "Inspect image";
      btn.disabled = false;
    });
    document.querySelectorAll(".accept-btn").forEach((btn) => {
      const imageId = btn.getAttribute("data-image-id");
      const item = state.files.find((f) => f.id === imageId);
      const inspected = !!item?.inspected;
      const decided = !!item?.approved || (inspected && item?.use === false);
      const canAccept = inspected && !decided;
      btn.style.display = canAccept ? "inline-flex" : "none";
      btn.disabled = !canAccept;
    });
    document.querySelectorAll(".reject-btn").forEach((btn) => {
      const imageId = btn.getAttribute("data-image-id");
      const item = state.files.find((f) => f.id === imageId);
      const inspected = !!item?.inspected;
      const decided = !!item?.approved || (inspected && item?.use === false);
      const canReject = inspected && !decided;
      btn.style.display = canReject ? "inline-flex" : "none";
      btn.disabled = !canReject;
    });
    document.querySelectorAll(".decision-btn").forEach((btn) => {
      const imageId = btn.getAttribute("data-image-id");
      const item = state.files.find((f) => f.id === imageId);
      const inspected = !!item?.inspected;
      const approved = !!item?.approved;
      const rejected = inspected && item?.use === false;
      const showDecision = approved || rejected;
      btn.style.display = showDecision ? "inline-flex" : "none";
      btn.textContent = approved ? "Change to Reject" : "Change to Accept";
      btn.disabled = !showDecision;
    });
    document.querySelectorAll(".inspect-status").forEach((badge) => {
      const wrap = badge.closest(".chat-image");
      const btn = wrap ? wrap.querySelector(".inspect-btn") : null;
      const imageId = btn ? btn.getAttribute("data-image-id") : null;
      const item = state.files.find((f) => f.id === imageId);
      badge.classList.remove("pending", "accepted", "rejected");
      if (!item?.inspected) {
        badge.textContent = "Not inspected";
        badge.classList.add("pending");
      } else if (item?.approved) {
        badge.textContent = "Accepted";
        badge.classList.add("accepted");
      } else if (item?.use === false) {
        badge.textContent = "Rejected";
        badge.classList.add("rejected");
      } else {
        badge.textContent = "Pending";
        badge.classList.add("pending");
      }
    });
    document.querySelectorAll(".image-desc").forEach((el) => {
      const imageId = el.getAttribute("data-image-id");
      const item = state.files.find((f) => f.id === imageId);
      el.textContent = item?.desc ? item.desc : "";
    });
  }

  function setupDropZone(){
    const drop = el('drop');
    const input = el('fileInput');

    drop.onclick = () => input.click();

    function handleFiles(fileList){
      [...fileList].forEach(f => {
        const item = { id: `${Date.now()}_${Math.random().toString(16).slice(2)}`, name: f.name, desc: '', data_url: '', use: true, inspected: false, approved: false };
        state.files.push(item);
        state.reviewTargetId = null;
        const reader = new FileReader();
        reader.onload = () => {
          item.data_url = reader.result || '';
          renderFileList();
          addChatImage(item);
        };
        reader.readAsDataURL(f);
      });
      renderFileList();
      updateInspectStatus();
    }

    drop.addEventListener('dragover', (e) => {
      e.preventDefault();
      drop.classList.add('drag');
    });
    drop.addEventListener('dragleave', () => drop.classList.remove('drag'));
    drop.addEventListener('drop', (e) => {
      e.preventDefault();
      drop.classList.remove('drag');
      if(e.dataTransfer?.files) handleFiles(e.dataTransfer.files);
    });

    input.addEventListener('change', (e) => {
      if(e.target.files) handleFiles(e.target.files);
      input.value = '';
    });
  }

  function setupControls(){
    el('runBtn').onclick = run;
    const showRowsInput = el('showRows');
    if (showRowsInput) {
      showRowsInput.oninput = () => renderResultsTable(state.lastResults);
    }

    // SCADA toggle
    const scadaToggle = el('scadaToggle');
    const mockDataToggle = el('mockDataToggle');
    const mockDataRow = el('mockDataRow');
    const scadaOverlay = el('scadaOverlay');
    const imageMockToggle = el('imageMockToggle');
    const imageMockRow = el('imageMockRow');
    const imageOverlay = el('imageOverlay');
    const imageSetLabeled = el('imageSetLabeled');
    const imageSetUnlabeled = el('imageSetUnlabeled');
    const confirmImageBtn = el('confirmImageSelection');
    const cancelImageBtn = el('cancelImageMock');
    const reselectImageBtn = el('reselectImageData');
    const reselectImageWrap = el('reselectImageWrap');
    const confirmScadaBtn = el('confirmScadaSelection');
    const reselectScadaBtn = el('reselectScadaData');
    const reselectScadaWrap = el('reselectScadaWrap');
    const cancelMockDataBtn = el('cancelMockData');
    const setMockOverlay = (open) => {
      el('scadaSection').classList.toggle('collapsed', !open);
      if (scadaOverlay) {
        scadaOverlay.classList.toggle('is-open', open);
      }
      if (open && imageOverlay) {
        imageOverlay.classList.remove('is-open');
        el('imageMockSection').classList.add('collapsed');
      }
    };
    const setImageOverlay = (open) => {
      el('imageMockSection').classList.toggle('collapsed', !open);
      if (imageOverlay) {
        imageOverlay.classList.toggle('is-open', open);
      }
      if (open && scadaOverlay) {
        scadaOverlay.classList.remove('is-open');
        el('scadaSection').classList.add('collapsed');
      }
    };
    const updateReselectVisibility = () => {
      if (!reselectScadaWrap || !mockDataToggle) {
        return;
      }
      const show = state.mockDataConfirmed && mockDataToggle.checked;
      reselectScadaWrap.classList.toggle('is-visible', show);
    };
    const updateMockDataVisuals = () => {
      if (mockDataRow) {
        mockDataRow.classList.toggle('is-pending', state.mockDataPending);
      }
      updateReselectVisibility();
      updateRunButtonAvailability();
    };
    const updateImageReselectVisibility = () => {
      if (!reselectImageWrap || !imageMockToggle) {
        return;
      }
      const show = state.mockImageConfirmed && imageMockToggle.checked;
      reselectImageWrap.classList.toggle('is-visible', show);
    };
    const updateImageMockVisuals = () => {
      if (imageMockRow) {
        imageMockRow.classList.toggle('is-pending', state.mockImagePending);
      }
      updateImageReselectVisibility();
      updateRunButtonAvailability();
    };
    const setImageDataset = (dataset) => {
      state.mockImageDataset = dataset;
      const labeledDisclaimer = el('imageLabeledDisclaimer');
      if (labeledDisclaimer) {
        labeledDisclaimer.style.display = dataset === 'labeled' ? 'block' : 'none';
      }
      if (imageSetLabeled && imageSetUnlabeled) {
        imageSetLabeled.classList.toggle('active', dataset === 'labeled');
        imageSetUnlabeled.classList.toggle('active', dataset === 'unlabeled');
      }
      loadMockImages(dataset);
    };
    const labeledDisclaimer = el('imageLabeledDisclaimer');
    if (labeledDisclaimer) {
      labeledDisclaimer.style.display = state.mockImageDataset === 'labeled' ? 'block' : 'none';
    }
    if (scadaToggle) {
      scadaToggle.checked = false;
    }
    if (mockDataToggle) {
      mockDataToggle.checked = false;
      setMockOverlay(false);
      mockDataToggle.onchange = () => {
        const wantsOn = mockDataToggle.checked;
        if (wantsOn) {
          state.mockDataPending = true;
          state.mockDataConfirmed = false;
          setMockOverlay(true);
        } else {
          setMockOverlay(false);
          state.mockDataPending = false;
          state.mockDataConfirmed = false;
        }
        updateMockDataVisuals();
        updateChatMetrics();
      };
    }
    if (imageMockToggle) {
      imageMockToggle.checked = false;
      setImageOverlay(false);
      imageMockToggle.onchange = () => {
        const wantsOn = imageMockToggle.checked;
        if (wantsOn) {
          state.mockImagePending = true;
          state.mockImageConfirmed = false;
          if (state.mockImageOptions.length) {
            renderMockImageGrid();
          } else {
            loadMockImages(state.mockImageDataset);
          }
          setImageOverlay(true);
        } else {
          setImageOverlay(false);
          state.mockImagePending = false;
          state.mockImageConfirmed = false;
          clearMockImageSelection();
          removeMockImageFiles();
          renderFileList();
          updateInspectStatus();
        }
        updateImageMockVisuals();
        updateChatMetrics();
      };
    }
    if (reselectScadaBtn && mockDataToggle) {
      reselectScadaBtn.onclick = () => {
        state.mockDataPending = true;
        mockDataToggle.checked = true;
        setMockOverlay(true);
        updateMockDataVisuals();
        updateChatMetrics();
      };
    }
    if (reselectImageBtn && imageMockToggle) {
      reselectImageBtn.onclick = () => {
        state.mockImagePending = true;
        imageMockToggle.checked = true;
        if (state.mockImageOptions.length) {
          renderMockImageGrid();
        } else {
          loadMockImages(state.mockImageDataset);
        }
        setImageOverlay(true);
        updateImageMockVisuals();
        updateChatMetrics();
      };
    }
    if (cancelMockDataBtn) {
      cancelMockDataBtn.onclick = () => {
        if (mockDataToggle) {
          mockDataToggle.checked = false;
        }
        state.mockDataPending = false;
        state.mockDataConfirmed = false;
        setMockOverlay(false);
        updateMockDataVisuals();
        updateChatMetrics();
      };
    }
    if (cancelImageBtn) {
      cancelImageBtn.onclick = () => {
        if (imageMockToggle) {
          imageMockToggle.checked = false;
        }
        state.mockImagePending = false;
        state.mockImageConfirmed = false;
        clearMockImageSelection();
        removeMockImageFiles();
        renderFileList();
        updateInspectStatus();
        setImageOverlay(false);
        updateImageMockVisuals();
        updateChatMetrics();
      };
    }
    if (confirmScadaBtn) {
      confirmScadaBtn.onclick = () => {
        const customInput = el('customTimeInput');
        const selectedId = el('scadaSelect')?.value;
        const selectedCard = selectedId ? state.filteredScadaCards.find((card) => card.id === selectedId) : null;
        const rawTime = selectedCard?.window_end
          || selectedCard?.case?.window?.end_time
          || selectedCard?.case?.source?.window_end
          || selectedCard?.window_start
          || selectedCard?.case?.window?.start_time
          || selectedCard?.case?.source?.window_start;
        const formattedTime = formatScadaDateTimeLocal(rawTime);
        const timeValue = formattedTime || (customInput && customInput.value ? customInput.value : formatDateTimeLocal(new Date()));
        if (customInput) {
          customInput.value = timeValue;
        }
        setMockOverlay(false);
        if (mockDataToggle) {
          mockDataToggle.checked = true;
        }
        state.mockDataPending = false;
        state.mockDataConfirmed = true;
        updateMockDataVisuals();
        updateChatMetrics();
      };
    }
    if (confirmImageBtn) {
      confirmImageBtn.onclick = () => {
        if (!applyMockImageSelection()) {
          return;
        }
        setImageOverlay(false);
        if (imageMockToggle) {
          imageMockToggle.checked = true;
        }
        state.mockImagePending = false;
        state.mockImageConfirmed = true;
        updateImageMockVisuals();
        updateChatMetrics();
      };
    }
    if (imageSetLabeled) {
      imageSetLabeled.onclick = () => setImageDataset('labeled');
    }
    if (imageSetUnlabeled) {
      imageSetUnlabeled.onclick = () => setImageDataset('unlabeled');
    }
    updateMockDataVisuals();
    updateImageMockVisuals();

    const range = el('rangeRows');
    if (range) {
      range.oninput = () => {
        el('rangeLabel').textContent = range.value;
        if (showRowsInput) {
          showRowsInput.value = range.value;
        }
        renderResultsTable(state.lastResults);
      };
    }

    const customTimeInput = el('customTimeInput');
    if (customTimeInput) {
      customTimeInput.value = formatDateTimeLocal(new Date());
    }

    document.querySelectorAll(".collapse-btn").forEach((btn) => {
      const targetId = btn.getAttribute("data-target");
      if (!targetId) {
        return;
      }
      btn.onclick = () => {
        const panel = el(targetId);
        if (!panel) {
          return;
        }
        panel.classList.toggle("collapsed");
        const isCollapsed = panel.classList.contains("collapsed");
        btn.classList.toggle("is-collapsed", isCollapsed);
        btn.setAttribute("aria-label", isCollapsed ? "Expand" : "Collapse");
        updateChatMetrics();
      };
    });
  }

  (async function init(){
    renderFileList();
    setupDropZone();
    setupControls();
    renderFaviconStatic();
    updateChatMetrics();
    window.addEventListener('resize', updateChatMetrics);
    await checkApiKeyStatus();
    try {
      await loadScadaOptions();
    } catch (e) {
      showWarn(e.message);
    }
    updateChatMetrics();
  })();
</script>
</body>
</html>
